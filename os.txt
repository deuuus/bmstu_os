Прерывания, обработчики прерывания.

Основа работы ОС - система прерываний. В монолитном ядре все построено на прерываниях.

Принято выделять: системные вызовы, исключения, аппаратные прерывания(interrupt).

Основная группа прерываний - от устройств ввода/вывода. 
Возникают, когда внешнее устройство завершило операцию ввода/вывода.
В соответствии с распараллеливанием функций в вычислительных системах.
Процессы не управляют внешними устройствами. Ими управляют специальные устройства.

В канальной архитектуре - каналы, в шинной - контроллеры (входят в состав устройств) 
или адаптеры (находятся на материнской плате). 

Получают команду, формируемую драйвером устройства. 
Часто говорят "процессор полысает команду".

Процессор должен быть проинформирован о завершении ввода/вывода.
Для информирования процессора предназначены аппаратные прерывания.

Работа процессора организована следующим образом: в цикле выполнения каждой 
программы процессор проверят не пришел ли сигнал прерывания на ножку. 
Если пришел, переходит на обработку этого прерывания.

(Спрашивают на экзамене в полном объеме, адресация прерываний в защищенном режиме).

Мы видели итог адресации в ЛР2. Итог - адресация обработчика прерывания и процессор
переходит на выполнение соответствующего обработчика прерывания (handler).

Аппаратные прерывания выполняются на высочайших уровнях приоритета в ядре. обработчики
прерывания являются одной из точек входа драйвера. Один драйвер может иметь один
обработчик прерывания.

[DPC Dispatch? IQL]

Уровень привелегий - кольца защиты, другая величина в отличие от уровней приоритета.

Когда выполняется аппаратное прерывание, никакая другая работа в системе выполняться
не может. SMP(Symmetric Multi Processing) - архитектура внесла в этот тезис 
некоторые изменения.

Тот процессор, который выполняет обработчик возникшего прерывания, на этом процессоре
запрещены все прерывания. Для остальных процессоров запрещены все прерывания по этой 
линии IRQ. Критическая ситуация для системы, поэтому обработчики должны завершаться 
как можно быстрее. Сказывается на отзывчивости системы.

Поэтому обработчики аппаратных прерываний выполняют минимально необходимый набор
действий. Например, такой ОАП для устройства ввода должен получить данные от устройства
и поместить их в буфер ядра. Всё. Процесс, который запрашивал ввод, он хотел получить
данные, поэтому ОАП делятся на 2 части: верхняя и нижняя половина. (top/bottom half)

Кроме сохранения пришедших данных, top half также инициализирует выполнение т.н. 
отложенных действий, чтобы система могла завершить обработку ввода/вывода.

В современных UNIX\Linux различают 3 типа нижних половин: soft irq's, tasklet,
io queue.

Исторические названия, они не меняются.

Любой драйвер может зарегистрировать в системе собственный обработчик прерывания.
Используются специальные функции (основная библиотека <linux/interrupts.h>):

/*struct pt_rets*/

typedef irqreturn_t (*irq_handler_t)(int, voud *);

int request_irq(unsigned int irq, void irq_handler_t handler, unsigned long flags,
                const char *name, void *dev);

typedef int irqreturn_t;

#defune IRQ_NONE (0)
#define IRQ_HANDLED (1)
#define IRQ_RETVAL(x) ((x) != 0)

Отсюда следует, что обработчик прерывания (результат его работы) может возвращать
или IRQ_NONE, или IRQ_HANDLED.

Деление действий, связанных с обслуживанием работы устройств в\в на аппаратные прерывания
и отложенные действия связано с уровнем приоритетов, на которых должны выполняться
АО и необходимости завершить обработку операций в\в и в итоге передать полученные
данные (в любом варианте, и когда процесс запрашивает операцию ввода, и когда
процесс запрашивает операцию вывода, процесс получает инф о выполненной операции).

В ядре различают 2 вида АП: быстрые и медленные. В современных Linux-системах к быстрым
прерываниям относят только прерывание от системного таймера, остальные медленные.

Важно отметить, что в версии 2.6.19 все флаги, связанные с прерыванием, были
радикально изменены. (sa_interrupt флаг, который обозначал быстре прерывания).
Приставка sa заменена на irqf. sa_interrupt => irqf_timer.

(level_triggered и edge_triggered.) 

Несколько флагов:

irqf_timer  0x00000200

irqf_shared 0x00000060 
//Устанавливается абонентами (теми, кто вызывает), чтобы 
разрешить разделение линии IRQ разными устройствами. Устройством управляет драйвер.
При этом даже одно устройство может иметь несколько обработчиков прерываний.
(Фактически пишем ЗМЯ, а не сам драйвер полностью).

irqf_probe_shared 0x00000100 
//Предполагается возможность наличия каких-либо проблем при совместном использовании
линии IRQ.

irqf_percpu 0x00000400
//Предполагает, что обрабтчик прерывания будет закреплен за определенным процессором.

Линиями прерывания можно управлять. Макросы управления линиями IRQ определены в 
<linux/irqflags.h>.
Для локального процессора __local_irq_disable(), __local_irq_enable().
Для запрета одной линии прерывания.

Для одной линиии IRQ:
__void disable_irq(unsigned int irq), __void disable_irq_nosync(unsigned int irq).
__void enable_irq(unsigned int irq).

Функция void synchronize_irq(unsigned int irq) предназначена для ожидания завершения 
обработчика прерывания по линии irq, если он выполняется.

Например, ОП от сетевого адаптера просто копирует пришедший пакет в ядро. В ядре пакет
ставится в буферную очередь, в которой ожидает обработки соотв. потоком ядра.

В любом случае, перед завершением ОАП, который наз. top half в нашем обсуждении,
инициализирует выполнение своей нижней половины (bottom half), отложенного действия.

После завершения выполнения ОАП (когда выполнен return), завершается взаимодействие
с контроллером прерываний, т.е. код аппаратного прерывания выполнен, восстанавливаются
локальные прерывания (разрешаются) на том процессоре, на котором выполнялся ОП,
восстанавливается старая маска прерываний (команда iret).

Продолжая мысль об обработчике прерывания сетевого адаптера, прерывание инициализирует
выполнение отложенного действия и нижняя половина завершит обработку получения пакета,
при этом смысл деления на половина заключается в том, что нижние половины выполняются
при разрешенных прерываниях.

soft irq (гибкие прерывания): в системе существует перечисление определенных в системе
гибких прерываний, они определяются статически при компиляции ядра.
<linux/interrupt.h>: определена структура 

struct softirq_action
{
    void (*action)(struct softirq_action *);
}

Когда ядро выполняет обработчик отложенного прерывания типа softirq, функция action
вызывается с указателем на структуру softirq_action в качестве параметра.

Количество типов softirq (имеет числовой индекс) статически определено в системе:

[индекс, приоритет, описание]

0. HI_SOFT_IRQ, 0, высокоприоретитный
1. TIMER_SOFT_IRQ, 1, таймеры
2. NET_TX_SOFT_IRQ, 2, отправка сетевых пакетов
3. NET_RX_SOFT_IRQ, 3, прием сетевых пакетов
4. BLOCK_SOFT_IRQ, 4, блочное устройство
5. BLOCK_IOPOLL_SOFT_IRQ, 5, опрос
6. TASKLET_SOFTIRQ, 6, тасклет
7. SHED_SOFTIRQ, 7, планировщик
8. HRTIMER_SOFTIRQ, 8, не исп.
9. RCU_SOFTIRQ, 9, д.б. последним
10. NR_SOFTIRQ, , число

const char * const softirq_to_name[NR_SOFTIRQ] = {"HI", "TIMER", "NET_XT", ..., "RCU"}
/proc/softirqs - здесь можно увидеть эту информацию

Определена функция

open_softirq

Поставить в очередь: void raise_softirq(unsigned int nr);

Добавить новый уровень можно только путем перекомпиляции ядра. Т.е. число обработчиков
не может быть изменено динамически. При этом надо понимать, что смысл имеет только
новое soft_irq, имеющее индекс на 1 меньше индекса tasklet, т.к. нет смысла 
переопределять кол-во soft_irq, т.к. можно использовать тасклет.

Из перечисления видно, что тасклет является одним из типов softirq.

void raise_softirq(unsigned int nr) с указанием конкретного индекса д.б. вызвана из
ОАП, т.е. ОАП должен отметить конкретное softirq как то, которое должно быть поставлено
в очередь на выполнение.

Выполнение softirq

Проверка ожидающих выполнения обработчиков отложенных действий типа softirq вып. в 
следующих случаях:

1. При возврате из аппаратного прерывания.
2. В контексте потока ядра ksoftirqd.
3. В любом коде ядра, в котором явно проверяются и запускаются ожидающие выполнения
обработчики softirq (например как это делается в сетевой подсистеме).

Независимо от способа вызова softirq, его выполнение осущ. функцией do_softirq.
Проверяет наличие отложенных прерываний, т.е. каждый поток ядра ksoftirqd выполняет функцию
run_ksoftirqd, проверяет наличие отложенных действий.

net rx softirq open_softirq

14.05.2022

Прерывания. Механизмы обслуживания.

ksoftirqd - поток ядра на процессор, задача которого - планирование и запуск на выполнение soft_irq. 
Когда машина нагружена гибкими прерываниями soft_interrupts, которые обслуживаются при завершении аппаратного прерывания,
при этом таких прерываний в единицу времени может возникать много, каждое инициализирует свой обработчик отложенного действия, создается очередь, сюда же входит и тасклет.

При этом, например, по размеру очереди или по времени работы ksoftirqd можно определить степень давления на систему обращений от сетевого устройства.

Тасклет - хороший компромисс между производительностью системы и простотой использования. 
В отличие от softirq, которые регистрируются при компиляции системы и их количество определено в системе, 
тасклеты могут быть зарегистрированы как статически, так и динамически.

Очереди работы.

Несколько концепций очередей работ workqueue представляют собой связанные с работой структуры данных, которые легко перепутать, т.е. в ядре в отличие от тасклетов, 
над которым определена одна структура, над очередями определено несколько структур, каждая из которых играет важную роль.

Работа связывается с конкретной очередью. В системе определены worker (рабочий) - поток ядра work thread. В системе имеется worker pull.